<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <title>WebAR Ramen Log</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; font-family: sans-serif; }
        .ui-container {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 10000; display: flex; flex-wrap: wrap; gap: 8px; width: 95%; justify-content: center;
        }
        button, label {
            padding: 12px; background: rgba(0,0,0,0.8); color: white;
            border-radius: 10px; border: 1px solid white; font-size: 12px;
            flex: 1; min-width: 100px; text-align: center; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        #fileLabel { background: #4a4a4a; }
        #memoBtn { background: #2b5797; }
        #shotBtn { background: #b91d1d; flex: 2; font-size: 14px; }
        canvas.a-canvas { z-index: 1 !important; }
    </style>
</head>
<body style="margin: 0; overflow: hidden;">

    <div class="ui-container">
        <input type="file" id="fileInput" accept="image/*" style="display:none">
        <label for="fileInput" id="fileLabel">‚ë† ÂÜôÁúü</label>
        <button id="memoBtn" type="button">‚ë° „É°„É¢</button>
        <button id="shotBtn" type="button">üì∏ ÊíÆÂΩ±‰øùÂ≠ò</button>
    </div>

    <a-scene embedded 
             arjs="sourceType: webcam; debugUIEnabled: false;" 
             renderer="preserveDrawingBuffer: true; colorManagement: true;"
             vr-mode-ui="enabled: false" screenshot>
        <a-entity id="myCamera" camera look-controls></a-entity>
    </a-scene>

    <script>
        const scene = document.querySelector('a-scene');
        const fileInput = document.getElementById('fileInput');
        const fileLabel = document.getElementById('fileLabel');
        const memoBtn = document.getElementById('memoBtn');
        const shotBtn = document.getElementById('shotBtn');
        
        let selectedImgUrl = null;
        let pendingText = null;

        // --- ÂÜôÁúü„ÅÆÊ∫ñÂÇô ---
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const maxSide = 1024;
                        let w = img.width, h = img.height;
                        if (w > h) { if (w > maxSide) { h *= maxSide/w; w = maxSide; } }
                        else { if (h > maxSide) { w *= maxSide/h; h = maxSide; } }
                        canvas.width = w; canvas.height = h;
                        canvas.getContext('2d').drawImage(img, 0, 0, w, h);
                        selectedImgUrl = canvas.toDataURL('image/jpeg', 0.8);
                        fileLabel.innerText = "‚úÖ ÈÖçÁΩÆOK";
                        fileLabel.style.background = "#2e7d32";
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // --- „É°„É¢„ÅÆÊ∫ñÂÇô ---
        memoBtn.addEventListener('click', () => {
            const text = prompt("Â∫óÂêç„ÇÑÊÑüÊÉ≥„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ", "");
            if (text) {
                pendingText = text;
                memoBtn.innerText = "‚úÖ „É°„É¢ÈÖçÁΩÆOK";
                memoBtn.style.background = "#2e7d32";
            }
        });

        // --- ARÈÖçÁΩÆÂá¶ÁêÜ ---
        const placeObject = (e) => {
            if (e.target.closest('.ui-container')) return;
            if (!selectedImgUrl && !pendingText) return;

            const cameraObj = document.getElementById('myCamera').object3D;
            const pos = new THREE.Vector3();
            const dir = new THREE.Vector3();
            cameraObj.getWorldPosition(pos);
            cameraObj.getWorldDirection(dir);
            const targetPos = { x: pos.x + dir.x * -2, y: pos.y + dir.y * -2, z: pos.z + dir.z * -2 };

            // ÂÜôÁúü„ÇíÈÖçÁΩÆ„Åô„ÇãÂ†¥Âêà
            if (selectedImgUrl) {
                const plane = document.createElement('a-plane');
                plane.setAttribute('position', targetPos);
                plane.setAttribute('look-at', '#myCamera');
                plane.setAttribute('material', 'side:double; shader:flat; transparent:true;');
                new THREE.TextureLoader().load(selectedImgUrl, (tex) => {
                    const aspect = tex.image.width / tex.image.height;
                    plane.setAttribute('width', 1.2 * aspect);
                    plane.setAttribute('height', 1.2);
                    plane.getObject3D('mesh').material.map = tex;
                });
                scene.appendChild(plane);
                selectedImgUrl = null; // 1ÂõûÈÖçÁΩÆ„Åó„Åü„Çâ„É™„Çª„ÉÉ„Éà
                fileLabel.innerText = "‚ë† ÂÜôÁúü";
                fileLabel.style.background = "rgba(0,0,0,0.8)";
            } 
            // „É°„É¢„ÇíÈÖçÁΩÆ„Åô„ÇãÂ†¥Âêà
            else if (pendingText) {
                const container = document.createElement('a-entity');
                container.setAttribute('position', targetPos);
                container.setAttribute('look-at', '#myCamera');

                // ÊñáÂ≠óËÉåÊôØ„ÅÆÊùø
                const bg = document.createElement('a-plane');
                bg.setAttribute('width', 1.5);
                bg.setAttribute('height', 0.4);
                bg.setAttribute('material', 'color: black; opacity: 0.7; shader: flat;');
                
                // ÊñáÂ≠óÔºàÊó•Êú¨Ë™ûÂØæÂøú„ÅÆ„Åü„ÇÅÁîªÂÉè„Åß„ÅØ„Å™„Åèa-text„Çí‰ΩøÁî®„ÄÇ„Éï„Ç©„É≥„ÉàÊåáÂÆö„Å™„Åó„Åß„ÇÇÊ®ôÊ∫ñ„ÅßÂá∫„Åæ„ÅôÔºâ
                const textEl = document.createElement('a-text');
                textEl.setAttribute('value', pendingText);
                textEl.setAttribute('align', 'center');
                textEl.setAttribute('width', 4);
                textEl.setAttribute('wrap-count', 20); // ÊñáÂ≠óÊï∞„Å´Âøú„Åò„Å¶Ë™øÊï¥
                textEl.setAttribute('color', 'white');

                container.appendChild(bg);
                container.appendChild(textEl);
                scene.appendChild(container);
                
                pendingText = null;
                memoBtn.innerText = "‚ë° „É°„É¢";
                memoBtn.style.background = "#2b5797";
            }
        };

        window.addEventListener('touchstart', placeObject);
        window.addEventListener('mousedown', placeObject);

        // --- ÊíÆÂΩ±ÂêàÊàêÔºà‰ª•Ââç„ÅÆÂÆåÊàêÁâà„Åù„ÅÆ„Åæ„ÅæÔºâ ---
        shotBtn.addEventListener('click', async () => {
            try {
                const video = document.querySelector('video');
                const sceneCanvas = scene.components.screenshot.getCanvas('perspective');
                const finalCanvas = document.createElement("canvas");
                finalCanvas.width = video.videoWidth; finalCanvas.height = video.videoHeight;
                const ctx = finalCanvas.getContext("2d");
                ctx.drawImage(video, 0, 0, finalCanvas.width, finalCanvas.height);
                
                const vAspect = video.videoWidth / video.videoHeight;
                const cAspect = sceneCanvas.width / sceneCanvas.height;
                let drawW, drawH, offsetX, offsetY;
                if (cAspect > vAspect) {
                    drawH = finalCanvas.height; drawW = finalCanvas.height * cAspect;
                    offsetX = (finalCanvas.width - drawW) / 2; offsetY = 0;
                } else {
                    drawW = finalCanvas.width; drawH = finalCanvas.width / cAspect;
                    offsetX = 0; offsetY = (finalCanvas.height - drawH) / 2;
                }
                ctx.drawImage(sceneCanvas, offsetX, offsetY, drawW, drawH);

                const dataURL = finalCanvas.toDataURL('image/png');
                if (navigator.share) {
                    const blob = await (await fetch(dataURL)).blob();
                    const file = new File([blob], `ramen-log.png`, { type: 'image/png' });
                    await navigator.share({ files: [file] });
                } else {
                    const link = document.createElement('a');
                    link.download = `ramen-log.png`; link.href = dataURL; link.click();
                }
            } catch (err) { console.error(err); }
        });
    </script>
</body>
</html>